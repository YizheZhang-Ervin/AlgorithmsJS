// 输入[1->4->5,1->3->4,2->6],输出1->1->2->3->4->4->5->6
// 暴力法:时间O(nk*log(nk))
// 分治法:两个两个链合并，时间O(nk*logk)，空间O(1)
// 最小堆:每次比较k个链表头O(k)，对k个链表头创建大小为k的最小堆，时间O(nk*logk)

let merge = function(){
// 定义一个空链表头

// 定义一个最小堆保存k个链表节点

// 将k个链表的头放到最小堆中

// 将最小堆中最小节点取出插入到结果链表中

// 如果节点后还有后续节点，将其点加入到最小堆中

// 最后返回结果链表

}

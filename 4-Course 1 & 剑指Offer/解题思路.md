# 查找  
1.二维数组查找  
从右上角开始搜索，target>右上则在下一行，target<右上则在左边一列    
  
31.整数1出现的次数  
Math.floor(n/10/i)*i + Math.min(Math.max(n%(10*i)-i+1,0),i)    
  
# 排序  
28.数组中出现次数超过一半的数字  
不相同数字相互抵消，剩下的数字就可能为超一半的数字  
在统计这个数字出现次数，如果>数组长度的一半则return  
  
29.最小的K个数  
方法1: 最小堆    
方法2: 冒泡排序    
  
63.数据流中的中位数  
插入排序，然后找排在中间位置的数  
  
# 穷举  
41.输出所有和为S的连续正数序列   
双指针双重循环，外层指针指向开始值，内层指针代表增量  
  
# 数学  
11.输入一个整数，输出该数32位二进制表示中1的个数  
每与一次，去掉一个零 n&(n-1)  
  
12.求base的exponent次方  
**或者Math.pow()  
  
47.1+···+n  
方法1: (1+n)*n/2  
方法2: 递归+逻辑与运算
  
48.不用加减乘除做加法  
异或=个位相加，与、左移=进位，无进位时循环结束  
  
49.将一个字符串转换成一个整数  
遍历一遍看每个字符是不是都在1-9内，并看第一位是不是+-号  
  
# 二分  
6.输出旋转数组的最小元素  
中间>最右，则最小值在右边  
中间<最右，则最小值在左边  
中间<中间-1，则中间为最小值  
  
33.只包含质因子2、3和5的数称作丑数，求按从小到大的顺序的第N个丑数  
三个指针分别指向2.3.5的倍数，每次把最小值放入丑数列表，放入后指针+1 
  
37.数字在升序数组中出现的次数  
二分查找数字出现的下界和上界  
  
# 数组  
7.斐波那契数列  
从2开始f(n)=f(n-1)+f(n-2)，0时0，1时1  
  
13.调整数组顺序使奇数位于偶数前面  
方法1: 两个数组一个存奇数，一个存偶数  
方法2: 遇到偶数就把后面的第一个出现的奇数提前  
  
19.顺时针打印矩阵  
顶上行结束后顶部起始行+1，右侧列结束后结束列-1  
起始行>结束行或起始列>结束列提前结束  
底下行结束后结束行-1，左侧列结束后起始列+1  
  
32.把数组排成最小的数  
贪心算法，两两比较ij和ji，ij>ji则j排在前  
  
35.数组中的逆序对  
归并排序时左>右，右数字的移动次数=逆序对个数  
  
50.数组中重复的数字  
遍历数组，第一次出现和最后一次出现索引位置不一样则记为重复
   
51.构建乘积数组  
方法1: 两重循环    
方法2: 上三角循环乘积+下三角循环乘积  
  
# 字符串  
2.替换空格  
方法1:replace  
方法2:split+join  
方法3:开辟新字符串  
  
34.第一个只出现一次的字符  
方法1:indexof+lastindexof一致的字符  
方法2:字典统计出现次数  
  
43.左旋转字符串  
移位数对字符串长度取余为真实移动位数，然后用substr拼接字符串  
  
44.翻转单词顺序列  
split+reverse+join  
  
45.扑克牌顺子  
长度不为5排除，去掉0后最大最小差>=5排除，有重复排除，其他情况就是顺子  
  
52.正则表达式匹配(同leetcode10)  
方法1: 递归  
方法2: 动态规划  
  
53.表示数值的字符串  
方法1: regexp  
方法2: isNaN  
  
54.字符流中第一个不重复的字符  
每次输入时检查是否之前出现过，未出现过则加入arr，出现过则从arr中删除  
  
# 双指针  
42.和为s的两个数字  
头尾指针所指的数< sum，头指针+1   
头尾指针所指的数> sum,尾指针-1  
头尾指针所指的数相加=sum，头指针+1，尾指针-1  
  
64.滑动窗口最大值(同leetcode239)  
方法1:slice  
方法2:每一次滑动的时候都有一个最大值，而如果滑出的那个不是最大值，那么就可以直接使用最大值和新加入的值进行比较，就不需要完全重新算  
    
# 递归  
8.跳台阶  
从2开始f(n)=f(n-1)+f(n-2)，1时1，2时2  
   
10.矩形覆盖
从2开始f(n)=f(n-1)+f(n-2)，1时1，2时2    
   
# 位运算  
40.数组中只出现一次的数字  
方法1:indexof等于lastindexof的数字加入arr    
方法2:indexof<0加入arr，indexof>=0则splice  
    
# 栈  
5.两个栈实现队列  
栈1弹出一个，栈2压入一个  
  
20.包含min函数的栈  
每插入一个，就把最小值放入另一个栈中  
  
21.栈的压入、弹出序列  
按压入序列压入栈，压入后判断是否弹，栈不空且栈顶等于出站队列则弹出，最终栈空则为可能序列  
   
# 链表  
3.从尾到头打印链表  
正序遍历并插入列表0号位  
  
14.链表中倒数第K个结点  
定义两个指针，间隔为k，一起移动  
  
15.反转链表  
头指针指none，后面节点next指向前一个，另一个指针指向未翻转的节点  
  
25.复杂链表的复制  
遍历链表，复制每个结点，如复制结点A得到A1，将结点A1插到结点A后面  
重新遍历链表，复制老结点的随机指针给新结点，如A1.random = A.random.next  
拆分链表，将链表拆分为原链表和复制后的链表  
  
36.两个链表的第一个公共结点  
两个链表一起走，一个走完另一个走的步数k即为长的长度  
较长的链表先走k步，然后两个链表一起走走到指针相同即为公共节点  
  
46.孩子们的游戏  
f(n)=(f(n-1)+m)%n  
  
55.链表中环的入口结点  
快慢指针，快指针走到none无环，快指针与慢指针相遇则有环  
初始化：快指针fast指向头结点， 慢指针slow指向头结点  
让fast一次走两步， slow一次走一步，第一次相遇在C处，停止  
然后让fast指向头结点，slow原地不动，然后fast，slow开始走，当再次相遇，就是入口结点  
  
56.删除链表中重复的结点  
遍历单链表的时候，检查当前节点与下一点是否为相同值  
如果相同，继续查找相同值的最大长度，然后指针改变指向  
  
# 树  
4.重建二叉树  
递归，根据先序遍历确定根，再递归求子树的根  
  
17.树的子结构  
先从根找，再在左子树找，再在右子树找  
  
18.二叉树的镜像  
迭代左右子树，让左=右且右=左  
  
22.从上往下打印二叉树  
根的左右子树迭代加入要遍历序列的队列，再出队列分别遍历将结果加入结果数组  
  
23.二叉搜索树的后序遍历序列  
最后一个节点是根，迭代划分左子树、右子树，右子树出现比根小的树就false    
  
24.二叉树中和为某一值的路径  
广度优先遍历，往下找直到叶子节点，总和为23则记路径，路径长的插在前面    
  
38.二叉树的深度  
使用队列进行层次遍历  
若root节点不为null,则将其加入到队列中  
然后当队列非空时就进行层次遍历,每次遍历时,层次+1.直到遍历结束,返回层次  
  
39.平衡二叉树  
求出以每个结点为根的树的高度，然后再根据左右子树高度差绝对值小于等于1,就可以判断以每个结点为根的树是否满足定义    
  
57.二叉树的下一个结点  
有右子树，下一结点是右子树中的最左结点  
无右子树，且结点是该结点父结点的左子树，则下一结点是该结点的父结点  
无右子树，且结点是该结点父结点的右子树，则我们一直沿着父结点追朔，直到找到某个结点是其父结点的左子树，如果存在这样的结点，那么这个结点的父结点就是我们要找的下一结点  
  
58.对称的二叉树  
左右子树值比较，左的左与右的右比较，左的右与右的左比较  
  
59.按之字形顺序打印二叉树  
用两个栈，单数行加到栈1中(先右后左)取pop，双数行加到栈2中(先左后右)取pop
  
60.把二叉树打印成多行  
用两个队列，单数行加到队列1中(先左后右)取[0]，双数行加入队列2中(先左后右)取[0]  
   
61.序列化二叉树  
先序遍历，节点空则用#    
  
62.二叉搜索树的第k个结点  
对中序遍历的结果中，取第K个元素即可。这里可以使用数字或者集合存储遍历结果，然后取第k个，但是会产生额外的空间复杂度，当然也可以使用一个变量记录遍历的节点数，当遍历到K个节点时即为所求   
  
# dfs、回溯  
65.矩阵中的路径  
dfs+回溯:当前处理的问题是：判断字符串str[0 ... len]是否在mat中匹配，显然下一次递归处理的问题是:如果str[0]已经匹配，则判断字符串str[1 ... len]是否在mat中匹配    
  
66.机器人的运动范围   
在原点作为起点，调用第一次递归后，在递归方法中，首先判断边界条件以及题目中所提的要求是否满足（本题的要求就是cal方法中的实现），都没问题，说明该位置可以访问，然后改变对应位置的标记。然后就是以该节点为中心，考虑下一步怎么走，本题就是4种走法，可以分开写，也可以一起写，由于本题是计数，所以就直接加在一起。然后return这些求和结果再+1，求和结果是下一步走的结果，而+1是本次访问此时的节点的次数  
  
# 动态规划  
27.字符串的排列  
定义数据结构，为每个字符增加方向属性，向左或向右。如果当前字符指向的字符比他小，那么称它是可移动的，其余情况皆不可移动。  
将给定序列初始化为字典序最小。每个字符的方向初始化为向左  
找出最大的可移动字符c，并移动它  
对于比c大的字符，将它们的方向调转  
重复2、3直到所有字符均不可移动  
  
30.连续子数组的最大和  
arr中每一位都记录此位和前一位的关系(如果和大于前一位则记为和，如果和小于前一位则记为前一位的值)  
  
# 贪婪算法  
9.变态跳台阶  
f(n)=2f(n-1)  
  
67.剪绳子  
number>=5时，尽可能多3的段  
number==4时，剪成2*2  
  
# 分而治之  
16.合并两个排序的链表(同leetcode21)  
两表头值比较，小的连上去  
一表为空，直接返回另一表  
一表提前结束，直接接上另一表  
  
26.二叉搜索树与双向链表  
连左子树最右，连右子树最左，最后输出链表头(最左)  
  
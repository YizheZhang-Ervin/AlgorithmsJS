一、理论
1.数据结构
栈/队列/集合/链表/字典/树/图/堆
2.进阶算法
冒泡/选择/插入/归并/快速/顺序/二分搜索
3.设计思想
分而治之/动态规划/贪心/回溯

二、类型
1.链表:遍历链表、删除链表节点
2.树/图:深度优先遍历/广度优先遍历
3.数组:冒泡/选择/插入/归并/快速排序、顺序/二分搜索

三、复杂度
1.时间复杂度:定性描述算法运行时间O()
2.空间复杂度:临时占用存储空间大小的度量

四、运行
1.打断点+F5

五、数据结构
1.栈stack
pop出栈/push入栈/stack[-1]栈顶
后进先出场景(有序)
(1)十进制转二进制->倒序取余数
(2)判断字符串括号是否有效->左括号入栈，右括号出栈
(3)函数调用堆栈(JS解释器)->最后调用最先执行完

2.队列queue
push入队/shift出队/queue[0]队头
先进先出场景(保证有序)，单线程
(1)排队打饭
(2)异步任务队列->JS单线程无法异步处理并发，所以用队列处理异步任务
(3)计算最近请求次数->队列长度就是最近请求次数

3.链表linked list
多元素列表，不连续存储，用next指针相连(有序)
数组增删非首尾元素要移动元素
链表增删非首尾元素不用移动元素，只要改next指向
场景
(1)js原型链是链表
(2)链表指针可以获取json节点值

4.集合Set
new创/add增/delete删/has查询/size大小/迭代用keys()、values()、entries()均可，因为key和value相同
set转array用[...xxset]/Array.from(xxset)
array转set用new Set(xxArr)
无序，唯一
用处:
(1)去重
(2)判断元素是否在集合中
(3)求交集-> set1.filter(item=>set2.has(item))
(4)求差集-> set1.filter(item=>!set2.has(item))

5.字典Map
存储唯一值，键值对形式存储
用处:
(1)键值对的set(k,v)增改/get(k)查/delete(k)删/clear()清空/size大小

6.树tree
分层数据的抽象模型
可以用Object和Array构建
应用:
DOM树、级联选择、树形控件(按json渲染树组件:用深度遍历)
操作:
深度广度优先遍历、二叉树(先中后序遍历)

7.图graph
网络结构的抽象模型，一组由边连接的节点
可以表示任何二元关系，如路/航班
图表示法:邻接矩阵、邻接表、关联矩阵
常用操作:深度优先遍历、广度优先遍历

8.堆
特殊的完全二叉树
最大堆:所有节点都大于等于子节点
最小堆:所有节点都小于等于子节点
左侧子节点位置2*index+1
右侧子节点位置2*index+2
父节点位置(index-1)/2
作用:
(1)堆能高效快速地找出最大值和最小值，时间复杂度O(1)
(2)找出第K个最大元素:最小堆，把元素不断插入，堆容量超过K删堆顶，插入结束堆顶就是第K大元素
(3)找出第K个最小元素:最大堆

六、排序搜索

七、策略
1.分而治之
算法设计中的一种方法
问题分为多个和原问题相似的小问题(相互独立)，递归解决小问题，再结果合并以解决原来的问题
应用场景:归并排序、快速排序、二分搜索、翻转二叉树

2.动态规划
算法设计中的一种方法
将一个问题分解为相互重叠的子问题(定义子问题)，通过反复求解子问题来解决原来的问题(反复执行)
应用:斐波那契数列

3.贪心算法
算法设计中的一种方法
每个阶段局部最优选择，从而达到全局最优
结果并不一定最优

4.回溯算法
算法设计中的一种方法
渐进式寻找并构建问题解决方式的策略
回溯算法会先从一个可能的动作开始解决问题，如果不行就回苏并选择另一个动作，直到把问题解决
适合场景:有很多路、路里有思路出路、需要递归模拟所有路
应用:全排列(模拟全部、封死不符合、收集到终点的方法)、子集(元素有序性、子集长度)
一、理论
1.数据结构
栈/队列/集合/链表/字典/树/图/堆
2.进阶算法
冒泡/选择/插入/归并/快速/顺序/二分搜索
3.设计思想
分而治之/动态规划/贪心/回溯

二、类型
1.链表:遍历链表、删除链表节点
2.树/图:深度优先遍历/广度优先遍历
3.数组:冒泡/选择/插入/归并/快速排序、顺序/二分搜索

三、复杂度
1.时间复杂度:定性描述算法运行时间O()
2.空间复杂度:临时占用存储空间大小的度量

四、运行
1.打断点+F5

五、数据结构
1.栈stack
pop出栈/push入栈/stack[-1]栈顶
后进先出场景(有序)
(1)十进制转二进制->倒序取余数
(2)判断字符串括号是否有效->左括号入栈，右括号出栈
(3)函数调用堆栈(JS解释器)->最后调用最先执行完

2.队列queue
push入队/shift出队/queue[0]队头
先进先出场景(保证有序)，单线程
(1)排队打饭
(2)异步任务队列->JS单线程无法异步处理并发，所以用队列处理异步任务
(3)计算最近请求次数->队列长度就是最近请求次数

3.链表linked list
多元素列表，不连续存储，用next指针相连(有序)
数组增删非首尾元素要移动元素
链表增删非首尾元素不用移动元素，只要改next指向
场景
(1)js原型链是链表
(2)链表指针可以获取json节点值

4.集合Set
new创/add增/delete删/has查询/size大小/迭代用keys()、values()、entries()均可，因为key和value相同
set转array用[...xxset]/Array.from(xxset)
array转set用new Set(xxArr)
无序，唯一
用处:
(1)去重
(2)判断元素是否在集合中
(3)求交集-> set1.filter(item=>set2.has(item))
(4)求差集-> set1.filter(item=>!set2.has(item))

5.字典Map
存储唯一值，键值对形式存储
用处:
(1)键值对的set(k,v)增改/get(k)查/delete(k)删/clear()清空/size大小

6.树tree
分层数据的抽象模型
可以用Object和Array构建
应用:
DOM树、级联选择、树形控件(按json渲染树组件:用深度遍历)
操作:
深度广度优先遍历、二叉树(先中后序遍历)

7.图graph
网络结构的抽象模型，一组由边连接的节点
可以表示任何二元关系，如路/航班
图表示法:邻接矩阵、邻接表、关联矩阵
常用操作:深度优先遍历、广度优先遍历

8.堆


六、排序搜索

七、策略
1.分而治之

2.动态规划

3.贪心算法

4.回溯算法

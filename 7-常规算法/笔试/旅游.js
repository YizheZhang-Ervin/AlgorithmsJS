// n个地点，找到一个尽可能长的路径，走过的每个地点高度依次下降，且经过的地点要尽可能多
// 给出一个有n个节点，m条边的无向图，每个节点有一个高度height

// 输入描述
// 第一行: n和m，表示地点数以及可以通行的路的数量。
// 第二行: n个数，分别表示height1,...,heightn，即依次从第一个地点......最后一个地点的高度。
// 接下来m行: 每行两个数u，v，表示存在一条可以走的路，使得u与v之间互相可以直达（即，其为双向边，既可以从u走向v，也可以从v走向u）
// 1≤n,m≤105, 0≤heighti≤109，1≤u,v≤n，可能有重边或自环，数据均为整数。

// 输出描述
// 输出一个整数，最长路径的长度（最多可以旅行的地点数）。

// 输入
// 5 4
// 3 2 3 4 6
// 1 2
// 2 3
// 3 4
// 4 5
// 输出
// 4
// 解释: 5->4->3->2，高度为6，4，3，2

// 输入2
// 2 1
// 1 2
// 1 2
// 输出
// 2
// 解释: 2->1

let longestPath = (n,m,heightArr,...path) =>{
    
}

longestPath(5,4,[3,2,3,4,6],[1,2],[2,3],[3,4],[4,5]);